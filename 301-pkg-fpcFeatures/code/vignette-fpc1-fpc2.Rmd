---
title: "FPC1 and FPC2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fpc1-fpc2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
    )
```
This vignette demonstrates the use of the R6 class **fpcFeatureEngine**
in the R package **fpcFeatures**.
An **fpcFeatureEngine** object can be used to compute, and store,
the *functional principal components* (also referred to as *harmonics*)
of an input (training) data set consisting of a collection
of time series.
A trained **fpcFeatureEngine** object can then be used to compute
the corresponding functional principal component scores for a _new_
collection of time series.

The finest temporal resolution allowed by **fpcFeatureEngine**
is one measurement per day, and **fpcFeatureEngine** assumes that
all measurements of each time series are made within the same
calendar year.

We demonstrate these functionalities in this vignette.

# 1. Preparing the demo data frame

### Load the **IW4** remote sensing time series data frame.

We will demonstrate the usage of **fpcFeatureEngine** using the data frame
**IW4**, which is bundled with the R package **fpcFeatures**.

First, load the **fpcFeatures** R package, and the other required packages
for this vignette:
```{r setup}
require(fpcFeatures)
require(ggplot2)
require(knitr)
require(logger)
```

Now that we have loaded the package **fpcFeatures**,
we load the embedded data frame **IW4**, and examine its structure.
```{r IW4}
data(IW4);
str(IW4);
```

The IW4 data frame contains VV time series measurements from approximately
5500 locations (each specified by geocoordinates) for the growing seasons
of the calendar years 2017, 2018 and 2019.
For each location and each year, the corresponding measurement time series
starts around early April and extends to around late October or early November,
at an observation frequency of one measurement every 12 days.

Here are the first few rows of IW4:
```{r headIW4}
knitr::kable(head(IW4), align = "c")
```

### Form the **DF.VV** data frame.

In what follows, we will work with the VV variable.
We form a new data frame **DF.VV** by extracting from IW4
the VV measurements, the dates and the geocoordinates.
**fpcFeatureEngine** requires its input data frame
to have its location identifier as a single variable.
We therefore create a custom unique location idenfitier
by concatenating the two geocoordinates:
```{r}
DF.VV <- IW4[,c('x','y','date','VV')];
DF.VV[,'x_y'] <- base::apply(
    X      = DF.VV[,c('x','y')],
    MARGIN = 1,
    FUN    = function(x) { return(base::paste(x,collapse="_")) }
    );
```

### Split **DF.VV** _by location_ into **training** and **new** subsets.

```{r}
locations <- base::unique(DF.VV[,'x_y']);

set.seed(7654321);
is.subset.1 <- sample(x = c(TRUE,FALSE), size = length(locations), replace = TRUE);
locations.1 <- locations[ is.subset.1];
locations.2 <- locations[!is.subset.1];

DF.VV.1 <- DF.VV[DF.VV[,'x_y'] %in% locations.1,];
colnames(DF.VV.1) <- paste0("my_",colnames(DF.VV.1));

DF.VV.2 <- DF.VV[DF.VV[,'x_y'] %in% locations.2,];
colnames(DF.VV.2) <- paste0("your_",colnames(DF.VV.2));
```

Here are the first few rows of **DF.VV.1**:
```{r}
knitr::kable(head(DF.VV.1), align = "c")
```

The first few rows of **DF.VV.2**:
```{r}
knitr::kable(head(DF.VV.2), align = "c")
```

# 2. Training (compute and store functional principal components based on training data)

### Training an **fpcFeatureEngine** object with the training data

```{r}
logger::log_threshold(level = logger::ERROR);

my.fpcFeatureEngine <- fpcFeatureEngine$new(
    training.data       = DF.VV.1,
    location            = 'my_x_y',
    date                = 'my_date',
    variable            = 'my_VV',
    n.partition         = 100,
    n.order             =   3,
    n.basis             =   9,
    smoothing.parameter =   0.1,
    n.harmonics         =   7
    );

my.fpcFeatureEngine$fit();
```

```{r harmonics, fig.height = 28, fig.width = 16}
my.fpcFeatureEngine$plot.harmonics();
```

# 3. Compute FPC scores for new data using a trained **fpcFeatureEngine** object.

### Compuint FPC scores for the new data using the trained **fpcFeatureEngine** object

```{r}
DF.land.cover <- base::unique(IW4[,c('x','y','land_cover')])
DF.land.cover[,'x_y'] <- base::apply(
    X      = DF.land.cover[,c('x','y')],
    MARGIN = 1,
    FUN    = function(x) { return(base::paste(x,collapse="_")) }
    );
DF.land.cover <- DF.land.cover[,c('x_y','land_cover')]
knitr::kable(head(DF.land.cover), align = "c", row.names = FALSE)
```

```{r transform}
DF.bspline.fpc <- my.fpcFeatureEngine$transform(
    newdata  = DF.VV.2,
    location = 'your_x_y',
    date     = 'your_date',
    variable = 'your_VV'
    );

DF.bspline.fpc <- base::merge(
    x    = DF.bspline.fpc,
    y    = DF.land.cover,
    by.x = 'your_x_y',
    by.y = 'x_y'
    )

DF.bspline.fpc <- DF.bspline.fpc[,c('your_x_y','year','land_cover',paste0('fpc_',1:7))]

knitr::kable(head(DF.bspline.fpc), align = "c", row.names = FALSE)
```

# 4. Visualize FPC scores of new data.

```{r fig.width = 16, fig.height = 12.5}
DF.colour.scheme <- data.frame(
    land_cover = c("marsh",  "swamp",  "water",  "forest", "ag",     "shallow"),
    colour     = c("#000000","#E69F00","#56B4E9","#009E73","#F0E442","red"    )
    )
rownames(DF.colour.scheme) <- DF.colour.scheme[,"land_cover"]
my.palette <- DF.colour.scheme[,"colour"]

textsize.title <- 50
textsize.axis  <- 35

my.ggplot <- ggplot2::ggplot(data = NULL) + ggplot2::theme_bw();
my.ggplot <- my.ggplot + ggplot2::theme(
    title            = ggplot2::element_text(size = textsize.title, face = "bold"),
    axis.title.x     = ggplot2::element_text(size = textsize.axis,  face = "bold"),
    axis.title.y     = ggplot2::element_text(size = textsize.axis,  face = "bold"),
    axis.text.x      = ggplot2::element_text(size = textsize.axis,  face = "bold"),
    axis.text.y      = ggplot2::element_text(size = textsize.axis,  face = "bold"),
    strip.text.y     = ggplot2::element_text(size = textsize.axis,  face = "bold"),
    legend.title     = element_blank(),
    legend.text      = ggplot2::element_text(size = textsize.axis),
    panel.grid.major = ggplot2::element_line(colour = "gray", linetype = 2, size = 0.25),
    panel.grid.minor = ggplot2::element_line(colour = "gray", linetype = 2, size = 0.25)
    );

my.ggplot <- my.ggplot + ggplot2::labs(title = NULL, subtitle = NULL)
my.ggplot <- my.ggplot + ggplot2::scale_colour_manual(values = my.palette)
my.ggplot <- my.ggplot + ggplot2::scale_fill_manual(  values = my.palette)
my.ggplot <- my.ggplot + guides(
    colour = guide_legend(override.aes = list(alpha =  0.75, size = 5))
    )

my.ggplot <- my.ggplot + scale_x_continuous(limits = 300*c(-1,1), breaks = seq(-300,300,100))
my.ggplot <- my.ggplot + scale_y_continuous(limits = 150*c(-1,1), breaks = seq(-150,150, 50))

my.ggplot <- my.ggplot + ggplot2::xlab("FPC 1 score")
my.ggplot <- my.ggplot + ggplot2::ylab("FPC 2 score")

my.ggplot <- my.ggplot + geom_point(
    data    = DF.bspline.fpc,
    mapping = aes(x = fpc_1, y = fpc_2, colour = land_cover),
    size    = 0.5,
    alpha   = 0.5
    )

my.ggplot
```

# 5. Goodness-of-fit diagnostics of individual time series.

```{r}
temp.x_y <- DF.VV.2[1,"your_x_y"]
print( temp.x_y );

DF.temp <- IW4[c("x","y","date","VV")];

DF.temp[,"year"] <- format(x = IW4[,'date'], format = "%Y")
is.selected.year <- ("2017" == DF.temp[,'year'])
DF.temp          <- DF.temp[is.selected.year,]

DF.temp[,"x_y"] <- apply(
    X      = DF.temp[,c('x','y')],
    MARGIN = 1,
    FUN    = function(x) { return(paste(x,collapse="_")) }
    )
colnames(DF.temp) <- paste0("their_",colnames(DF.temp))

DF.temp <- DF.temp[temp.x_y == DF.temp[,'their_x_y'],]
DF.temp <- DF.temp[,c("their_x_y","their_date","their_VV")]
knitr::kable(DF.temp, align = "c", row.names = FALSE)
```

```{r, fig.width = 16}
my.fpcFeatureEngine$plot.approximations(
    DF.input = DF.temp,
    location = "their_x_y",
    date     = "their_date",
    variable = "their_VV"
    )
```
